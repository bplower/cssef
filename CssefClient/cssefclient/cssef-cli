#!/usr/bin/python
import os
import sys
import traceback
import yaml
from prettytable import PrettyTable
from cssefclient.cssefclient import *

class Menu(object):
	def __init__(self):
		self.availableEndpoints = None
		self.menuDict = {}

	def loadFromServer(self, apiConn):
		print "[LOGGING] Querying server for available endpoints."
		result = AvailableEndpoints(apiConn).execute()
		if result['value'] != 0:
			print "[ERROR] Failed to get available endpoints"
			sys.exit()
		self.availableEndpoints = result['content']
		print "[LOGGING] Finished loading available endpoints."

	def loadFromFile(self, path):
		pass

	def construct(self):
		# Remote endpoints
		for moduleDict in self.availableEndpoints:
			self.menuDict[moduleDict['menuName']] = {}
			for endpointDict in moduleDict['endpoints']:
				self.menuDict[moduleDict['menuName']] = self.buildMenuBranch(
					self.menuDict[moduleDict['menuName']],	# This is the current menu
					endpointDict['menu'],					# This is the menu heiarchy
					endpointDict)							# This is the content for the end of the menu
		# Local endpoints
		#hardcode the endpoints for now
		self.menuDict['login'] = {
			"name": "Login",
			"celeryName": "login",
			"menu": [],
			"arguments": []
		}


	def buildMenuBranch(self, currentMenu, menuList, endpointContent):
		if len(menuList) == 1:
			currentMenu[menuList[0]] = endpointContent
			return currentMenu
		else:
			try:
				currentMenu[menuList[0]] = self.buildMenuBranch(currentMenu[menuList[0]], menuList[1:], endpointContent)
			except KeyError:
				currentMenu[menuList[0]] = {}
				currentMenu[menuList[0]] = self.buildMenuBranch(currentMenu[menuList[0]], menuList[1:], endpointContent)
			return currentMenu

class ParseInput(object):
	def __init__(self):
		self.remainingArgs = sys.argv[1:]
		self.options = {}
		self.command = []
		self.commandArgs = {}
		self.parseInput()

	def parseInput(self):
		self.parseOptions()
		self.parseCommand()
		self.parseCommandArgs()

	def parseOptions(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.options[keyword] = value
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommand(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] != '-':
			self.command.append(self.remainingArgs[index])
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommandArgs(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.commandArgs[keyword] = value
			index += 1

def walkDictPath(d, l):
	if len(l) == 0:
		return None
	if len(l) == 1:
		return d[l[0]]
	else:
		return walkDictPath(d[l[0]], l[1:])

def execute(endpoint, arguments):
	try:
		output = endpoint.execute(**arguments)
	except Exception as e:
		output = {"value": -1, "message": [str(e)]}
	return output

def displayOutput(outputDict):
	if outputDict['value'] != 0:
		sys.stderr.write("The server encountered an error:\n")
		sys.stderr.write("\n".join(outputDict['message'])+"\n")
		sys.exit(outputDict['value'])
	if len(outputDict['content']) > 0:
		if output['content'].__class__.__name__ == "list":
			outputTable = PrettyTable(output['content'][0].keys())
			outputTable.padding_width = 1
			for i in outputDict['content']:
				outputTable.add_row(i.values())
			print outputTable
		elif output['content'].__class__.__name__ == "str":
			print output['content']
		else:
			print "Unknown outputDict content type: %s" % str(output['content'].__class__.__name__)

if __name__ == "__main__":
	"""
	Usage:
	cssef-cli [OPTIONS] [COMMAND] [ARGUMENTS]
	"""
	# Parse the command line arguments
	cliInput = ParseInput()
	# Load the various configuration files
	config = Configuration()
	config.loadConfigFile(config.globalConfigPath)
	config.loadConfigFile(config.configPath)
	config.loadConfigDict(cliInput.options)
	# Load token
	if config.token_auth_enabled:
		config.loadToken()
	# Establish rabbitmq connection
	apiConn = getConn(config)
	# Load the available endpoints
	m = Menu()
	m.loadFromServer(apiConn)
	m.construct()
	# Instantiate and execute the endpoint
	endpointDict = walkDictPath(m.menuDict, cliInput.command)
	if not endpointDict:
		print "Invalid endpoint."
		sys.exit(1)
	endpoint = CeleryEndpoint.fromDict(endpointDict, apiConn)
	output = execute(endpoint, cliInput.commandArgs)
	# Display the output
	displayOutput(output)