#!/usr/bin/python
import ast
import sys
from prettytable import PrettyTable
from cssefclient.cssefclient import *

class Menu(object):
	def __init__(self, config):
		self.config = config
		self.availableEndpoints = None
		self.menuDict = {}

	def loadFromServer(self):
		"""Retrieves the available endpoints from the server.
		"""
		if self.config.verbose:
			print "[LOGGING] Loading available endpoints from server."
		result = AvailableEndpoints(self.config).execute()
		if result['value'] != 0:
			sys.stderr.write("[ERROR] Failed to get available endpoints\n.")
			sys.stderr.flush()
			sys.exit()
		self.availableEndpoints = result['content']
		if self.config.verbose:
			print "[LOGGING] Finished loading available endpoints."
		self.construct()

	def loadFromFile(self, path):
		"""Retrieves the available endpoints from the cache
		"""
		if self.config.verbose:
			print "[LOGGING] Loading available endpoints from cache."
		fileContent = open(self.config.endpoint_cache_file, 'r').read()
		self.availableEndpoints = ast.literal_eval(fileContent)
		if self.config.verbose:
			print "[LOGGING] Finished loading available endpoints."
		self.construct()

	def construct(self):
		# Build dynamic celery endpoints
		for moduleDict in self.availableEndpoints:
			self.menuDict[moduleDict['menuName']] = {}
			for endpointDict in moduleDict['endpoints']:
				self.menuDict[moduleDict['menuName']] = self.buildMenuBranch(
					self.menuDict[moduleDict['menuName']],	# This is the current menu
					endpointDict['menu'],					# This is the menu heiarchy
					endpointDict)							# This is the content for the end of the menu

		# Build local endpoints
		self.menuDict['login'] = Login(self.config)
		self.menuDict['logout'] = Logout(self.config)

	def buildMenuBranch(self, currentMenu, menuList, endpointContent):
		if len(menuList) == 1:
			# This means endpointContent is a dictionary that defines an endpoint
			currentMenu[menuList[0]] = CeleryEndpoint.fromDict(self.config, endpointContent)
			return currentMenu
		else:
			try:
				currentMenu[menuList[0]] = self.buildMenuBranch(currentMenu[menuList[0]], menuList[1:], endpointContent)
			except KeyError:
				currentMenu[menuList[0]] = {}
				currentMenu[menuList[0]] = self.buildMenuBranch(currentMenu[menuList[0]], menuList[1:], endpointContent)
			return currentMenu

	def walkDictPath(self, d, l):
		"""This will walk down the path l through dictionary d
		Example:
			Given list l defined as `l = ['a', 'b', 'c']` and dictionary d
			defined as `d = {
				'a': {
					'b': {
						'c': "object1",
						'f': "object2"
					},
					'e': "object3"
				},
				'd': {
					'g': "object4"
				}
			}` this function will return object1
		"""
		if len(l) == 0:
			return None
		if len(l) == 1:
			return d[l[0]]
		else:
			return self.walkDictPath(d[l[0]], l[1:])

	def getCommand(self, commandList):
		"""Gets the selected command from the menu dictionary

		This uses the walkDictPath method to retrieve the selected celery
		endpoint based on the list of values in commandList.

		Args:
			commandList (list): List of menu names to traverse

		Returns:
			Command: Instantiated command class, which can be called to
				ececute the celery task
		"""
		return Command(self.walkDictPath(self.menuDict, commandList))

class ParseInput(object):
	def __init__(self):
		self.remainingArgs = sys.argv[1:]
		self.options = {}
		self.command = []
		self.commandArgs = {}
		self.parseInput()

	def parseInput(self):
		self.parseOptions()
		self.parseCommand()
		self.parseCommandArgs()

	def parseOptions(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.options[keyword] = value
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommand(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] != '-':
			self.command.append(self.remainingArgs[index])
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommandArgs(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.commandArgs[keyword] = value
			index += 1

	def prepareAuthDict(self, config):
		tmpDict = {}
		# If the admin token was provided, add that to the auth dict and then return since we don't need anything else.
		if "admin-token" in self.options:
			tmpDict["admin-token"] = self.options.pop("admin-token")
			self.commandArgs['auth'] = tmpDict
			return True
		# Add the username to the auth Dict
		if not config.username:
			print "No username was provided."
			return False
		tmpDict["username"] = config.username
		# Add the organization to the auth Dict
		if not config.organization:
			print "No organization was provided."
			return False
		tmpDict["organization"] = config.organization
		# If a password is provided, we want to use that instead of the token
		if config.password:
			tmpDict["password"] = config.password
		elif config.token_auth_enabled and config.token:
			tmpDict["token"] = config.token
		else:
			# Both values failed
			print "Neither password nor token were provided."
			return False
		self.commandArgs['auth'] = tmpDict
		return True

class Command(object):
	"""
	Todo: This can very likely be merged in with CeleryEndpoint.
	"""
	def __init__(self, endpoint):
		self.endpoint = endpoint

	def __call__(self, **kwargs):
		"""Wraps endpoint execution

		This the point of this is just to catch any unhandled server
		exceptions.

		Args:
			endpoint (Endpoint):
			arguments (dict): Keyword dictionary of arguments to pass to
				`endpoint.execute`.

		Returns:
			dict: returnDict with values filled in.
		"""
		try:
			outputDict = self.endpoint.execute(**kwargs)
		except Exception as e:
			outputDict = {"value": -1, "message": [str(e)], "content": []}
		return CommandOutput(**outputDict)

class CommandOutput(object):
	def __init__(self, value, message, content):
		self.value = value
		self.message = message
		# Cast the content to a list 
		if type(content) == list:
			self.content = content
		elif type(content) == str:
			self.content = [content]
		else:
			raise ValueError
		# Get the keys of the content if it's a dict
		if len(self.content) > 0 and type(self.content[0]) == dict:
			self.tableHeaders = self.content[0].keys()
		else:
			self.tableHeaders = None

	def display(self):
		if self.value != 0:
			sys.stderr.write("An error was encountered:\n")
			print self.message
			sys.stderr.write("\n".join(self.message)+"\n")
			sys.exit(self.value)
		if self.tableHeaders:
			# Its a dictionary list, make a table and print it
			outputTable = PrettyTable(self.tableHeaders)
			outputTable.padding_width = 1
			for i in self.content:
				outputTable.add_row(i.values())
			print outputTable
		else:
			# It's just a list of strings, print each one
			# TODO: Maybe I just shouldn't support this...
			for i in self.content:
				print i

if __name__ == "__main__":
	"""
	Usage:
	cssef-cli [OPTIONS] [COMMAND] [ARGUMENTS]
	"""
	# Parse the command line arguments
	cliInput = ParseInput()
	# Load the various configuration files
	config = Configuration()
	config.loadConfigFile(config.globalConfigPath)
	config.loadConfigFile(config.configPath)
	config.loadConfigDict(cliInput.options)
	# Load token
	if config.token_auth_enabled and not config.loadTokenFile():
		print "Failed to load token from file."
	# We need authentication set up now
	if not cliInput.prepareAuthDict(config):
		print "Failed to meet authentication requirements. Not using authentication."
	# Establish rabbitmq connection
	config.establishApiConnection()
	# Load the available endpoints
	commandMenu = Menu(config)
	commandMenu.loadFromServer()
	# Get the command, instantiate it, then call it
	# This is super temporary - I just want to get all of the server side stuff fixed first
	command = commandMenu.getCommand(cliInput.command)
	output = command(**cliInput.commandArgs)
	# Now display the output
	output.display()