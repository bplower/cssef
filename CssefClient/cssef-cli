#!/usr/bin/python
import os
import sys
from getpass import getpass
from prettytable import PrettyTable
import cssefclient
from cssefclient.utils import RPCEndpoint
from cssefclient.errors import NonExistantCommand

class Menu(object):
    def __init__(self, config, source_list):
        self.config = config
        self.source_list = source_list
        self.menu_dict = {}

    def construct(self):
        # Start by looping over the endpoint sources
        for source in self.source_list:
            for endpoint in source['endpoints']:
                self.menu_dict[endpoint['menu_path']] = \
                RPCEndpoint(self.config, endpoint['rpc_name'])

    def get_command(self, command_list):
        """Gets the selected command from the menu dictionary

        This converts the command_list to a string and then looks it up in the
        menu_dict to find the command instance.

        Args:
            command_list (list): List of menu names to traverse

        Returns:
            Command: Instantiated command class, which can be called to
                execute the rpc endpoint
        """
        menu_path = ".".join(command_list)
        try:
            return self.menu_dict[menu_path]
        except KeyError:
            print menu_path
            raise NonExistantCommand

class ParseInput(object):
    def __init__(self, input_list):
        self.remaining_args = input_list
        self.options = {}
        self.command = []
        self.command_args = {}
        self.parse_input()

    def parse_input(self):
        self.parse_options()
        self.parse_command()
        self.parse_command_args()

    def parse_options(self):
        index = 0
        while index < len(self.remaining_args) and self.remaining_args[index][0] == '-':
            argument = self.remaining_args[index]
            argument = argument.strip('-')
            if len(argument.split("=")) > 1:
                # The value is in the same argument
                keyword = argument.split('=')[0]
                value = argument.split('=')[1]
            else:
                # The value is in the next argument
                keyword = argument
                value = self.remaining_args[index + 1]
                index += 1
            self.options[keyword] = value
            index += 1
        self.remaining_args = self.remaining_args[index:]

    def parse_command(self):
        index = 0
        while index < len(self.remaining_args) and self.remaining_args[index][0] != '-':
            self.command.append(self.remaining_args[index])
            index += 1
        self.remaining_args = self.remaining_args[index:]

    def parse_command_args(self):
        index = 0
        while index < len(self.remaining_args) and self.remaining_args[index][0] == '-':
            argument = self.remaining_args[index]
            argument = argument.strip('-')
            if len(argument.split("=")) > 1:
                # The value is in the same argument
                keyword = argument.split('=')[0].replace('-', '_')
                value = argument.split('=')[1]
            else:
                # The value is in the next argument
                keyword = argument.replace('-', '_')
                try:
                    value = self.remaining_args[index + 1]
                except IndexError:
                    # There is no next error. Complain and quit
                    sys.exit("Expected value in for argument, but got none.")
                index += 1
            self.command_args[keyword] = value
            index += 1

def print_output(output):
    if output.value != 0:
        # A value of non-zero means there was an error of some kind.
        sys.stderr.write("The server is reporting the following error:\n")
        sys.stderr.write("\n".join(output.message)+"\n")
    if output.table_headers:
        # Its a dictionary list, make a table and print it
        output_table = PrettyTable(output.table_headers)
        output_table.padding_width = 1
        for i in output.content:
            output_table.add_row(i.values())
        print output_table
    else:
        # It's just a list of strings, print each one
        # TODO: Maybe I just shouldn't support this...
        for i in output.content:
            print i

if __name__ == "__main__":
    # Set up and configure the client
    user_input = ParseInput(sys.argv[1:])
    client = cssefclient.CssefClient()
    client.config.load_config_file(client.config.global_config_path)
    client.config.load_config_file(client.config.config_path)
    client.config.load_config_dict(user_input.options)
    client.config.load_token()

    # Ensure user data directory exists
    if not os.path.exists(client.config.user_data_dir):
        os.makedirs(client.config.user_data_dir)

    # Prepare the auth dictionary
    auth_builder = cssefclient.AuthBuilder(client.config)
    if not auth_builder.is_valid():
        sys.exit()
    user_input.command_args['auth'] = auth_builder.as_dict()

    # Make connection to server, load endpoints, authenticate
    client.connect()
    client.load_endpoints()

    # Call command and handle return
    commandMenu = Menu(client.config, client.endpoints)
    commandMenu.construct()

    command = commandMenu.get_command(user_input.command)
    output_obj = client.call_endpoint(command, user_input.command_args)
    print_output(output_obj)
    sys.exit(output_obj.value)
