#!/usr/bin/python
import ast
import sys
from cssefclient import Configuration
from cssefclient.utils import CeleryEndpoint
from cssefclient.tasks import AvailableEndpoints
from cssefclient.tasks import Login
from cssefclient.tasks import Logout
from cssefclient.tasks import RenewToken

class Menu(object):
	def __init__(self, config):
		self.config = config
		self.availableEndpoints = None
		self.menuDict = {}

	def loadFromServer(self):
		"""Retrieves the available endpoints from the server.
		"""
		if self.config.verbose:
			print "[LOGGING] Loading available endpoints from server."
		result = AvailableEndpoints(self.config).execute()
		if result.value != 0:
			# If this happens, we should eventually fail over to using the local cache
			errorMessage = "[ERROR] Server error while getting available endpoints.\n"
			errorMessage += "\n".join(result.message)
			sys.stderr.write("%s\n" % errorMessage)
			sys.stderr.flush()
			sys.exit()
		self.availableEndpoints = result.content
		if self.config.verbose:
			print "[LOGGING] Finished loading available endpoints."
		self.construct()

	def loadFromFile(self, path):
		"""Retrieves the available endpoints from the cache
		"""
		if self.config.verbose:
			print "[LOGGING] Loading available endpoints from cache."
		fileContent = open(self.config.endpoint_cache_file, 'r').read()
		self.availableEndpoints = ast.literal_eval(fileContent)
		if self.config.verbose:
			print "[LOGGING] Finished loading available endpoints."
		self.construct()

	def construct(self):
		# Build dynamic celery endpoints
		for moduleDict in self.availableEndpoints:
			self.menuDict[moduleDict['menuName']] = {}
			for endpointDict in moduleDict['endpoints']:
				self.menuDict[moduleDict['menuName']] = self.buildMenuBranch(
					self.menuDict[moduleDict['menuName']],	# This is the current menu
					endpointDict['menu'],					# This is the menu heiarchy
					endpointDict)							# This is the content for the end of the menu

		# Build local endpoints
		self.menuDict['login'] = Login(self.config)
		self.menuDict['logout'] = Logout(self.config)

	def buildMenuBranch(self, currentMenu, menuList, endpointContent):
		if len(menuList) == 1:
			# This means endpointContent is a dictionary that defines a celery
			# endpoint. We now instantiate the endpoint from that dictionary
			currentMenu[menuList[0]] = CeleryEndpoint.fromDict(
				self.config,
				endpointContent)
			return currentMenu
		else:
			try:
				currentMenu[menuList[0]] = self.buildMenuBranch(
					currentMenu[menuList[0]],
					menuList[1:],
					endpointContent)
			except KeyError:
				currentMenu[menuList[0]] = {}
				currentMenu[menuList[0]] = self.buildMenuBranch(
					currentMenu[menuList[0]],
					menuList[1:],
					endpointContent)
			return currentMenu

	def walkDictPath(self, d, l):
		"""This will walk down the path l through dictionary d
		Example:
			Given list l defined as `l = ['a', 'b', 'c']` and dictionary d
			defined as `d = {
				'a': {
					'b': {
						'c': "object1",
						'f': "object2"
					},
					'e': "object3"
				},
				'd': {
					'g': "object4"
				}
			}` this function will return object1
		"""
		if len(l) == 0:
			return None
		if len(l) == 1:
			return d[l[0]]
		else:
			return self.walkDictPath(d[l[0]], l[1:])

	def getCommand(self, commandList):
		"""Gets the selected command from the menu dictionary

		This uses the walkDictPath method to retrieve the selected celery
		endpoint based on the list of values in commandList.

		Args:
			commandList (list): List of menu names to traverse

		Returns:
			Command: Instantiated command class, which can be called to
				ececute the celery task
		"""
		return self.walkDictPath(self.menuDict, commandList)

class ParseInput(object):
	def __init__(self):
		self.remainingArgs = sys.argv[1:]
		self.options = {}
		self.command = []
		self.commandArgs = {}
		self.parseInput()

	def parseInput(self):
		self.parseOptions()
		self.parseCommand()
		self.parseCommandArgs()

	def parseOptions(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.options[keyword] = value
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommand(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] != '-':
			self.command.append(self.remainingArgs[index])
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommandArgs(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				try:
					value = self.remainingArgs[index + 1]
				except IndexError:
					# There is no next error. Complain and quit
					sys.exit("Expected value in for argument, but got none.")
				index += 1
			self.commandArgs[keyword] = value
			index += 1

	def prepareAuthDict(self, config):
		tmpDict = {}
		# If the admin token was provided, add that to the auth dict and then
		# return since we don't need anything else.
		if "admin-token" in self.options:
			tmpDict["admin-token"] = self.options.pop("admin-token")
			self.commandArgs['auth'] = tmpDict
			return True
		# Add the username to the auth Dict
		if not config.username:
			print "No username was provided."
			return False
		tmpDict["username"] = config.username
		# Add the organization to the auth Dict
		if not config.organization:
			print "No organization was provided."
			return False
		tmpDict["organization"] = config.organization
		# If a password is provided, we want to use that instead of the token
		if config.password:
			tmpDict["password"] = config.password
		elif config.token_auth_enabled and config.token:
			tmpDict["token"] = config.token
		else:
			# Both values failed
			print "Neither password nor token were provided."
			return False
		self.commandArgs['auth'] = tmpDict
		return True

def buildConfiguration(cliInput):
	# Load the various configuration sources
	config = Configuration()
	config.loadConfigFile(config.globalConfigPath)
	config.loadConfigFile(config.configPath)
	config.loadConfigDict(cliInput.options)
	# Load token
	if config.token_auth_enabled and not config.loadTokenFile():
		# This means token authentication is enabled, but we failed to load
		# the token from the file
		print "Failed to load token from file."
	# We need authentication set up now
	if not cliInput.prepareAuthDict(config):
		print "Failed to meet minimum authentication requirements. Not using authentication."
	return config

def processTokenRenewal(config):
	# Attempt to renew the auth token
	output = RenewToken(config).execute()
	if output.value != 0:
		print "[WARNING] Failed to renew auth token."
		if config.verbose:
			output.display()	

if __name__ == "__main__":
	"""
	Usage:
	cssef-cli [OPTIONS] [COMMAND] [ARGUMENTS]
	"""
	# Parse the command line arguments
	cliInput = ParseInput()
	config = buildConfiguration(cliInput)
	# Establish rabbitmq connection
	config.establishApiConnection()
	# Load the available endpoints
	commandMenu = Menu(config)
	commandMenu.loadFromServer()

	# Attempt to renew the auth token
	processTokenRenewal(config)

	# Get the command, instantiate it, then call it
	# This is super temporary - I just want to get all of the server side stuff fixed first
	command = commandMenu.getCommand(cliInput.command)
	output = command.execute(**cliInput.commandArgs)
	# Now display the output
	output.display()
	output.exitWithValue()