#!/usr/bin/python
import os
import sys
import cssefclient
from prettytable import PrettyTable
from cssefclient.utils import RPCEndpoint
from cssefclient.tasks import AvailableEndpoints
from cssefclient.tasks import Login
from cssefclient.tasks import Logout
from cssefclient.errors import NonExistantCommand

class Menu(object):
	def __init__(self, config, endpoints):
		self.config = config
		self.availableEndpoints = endpoints
		self.menuDict = {}

	def construct(self):
		# Build dynamic rpc endpoints
		for moduleDict in self.availableEndpoints:
			self.menuDict[moduleDict['menuName']] = {}
			for endpointDict in moduleDict['endpoints']:
				self.menuDict[moduleDict['menuName']] = self.buildMenuBranch(
					self.menuDict[moduleDict['menuName']],	# This is the current menu
					endpointDict['menu'],					# This is the menu heiarchy
					endpointDict)							# This is the content for the end of the menu

		# Build local endpoints
		self.menuDict['login'] = Login(self.config)
		self.menuDict['logout'] = Logout(self.config)

	def buildMenuBranch(self, currentMenu, menuList, endpointContent):
		if len(menuList) == 1:
			# This means endpointContent is a dictionary that defines a rpc
			# endpoint. We now instantiate the endpoint from that dictionary
			currentMenu[menuList[0]] = RPCEndpoint.fromDict(
				self.config,
				endpointContent)
			return currentMenu
		else:
			try:
				currentMenu[menuList[0]] = self.buildMenuBranch(
					currentMenu[menuList[0]],
					menuList[1:],
					endpointContent)
			except KeyError:
				currentMenu[menuList[0]] = {}
				currentMenu[menuList[0]] = self.buildMenuBranch(
					currentMenu[menuList[0]],
					menuList[1:],
					endpointContent)
			return currentMenu

	def walkDictPath(self, dictionary, path):
		"""This will walk down the path l through dictionary d
		Example:
			Given list l defined as `l = ['a', 'b', 'c']` and dictionary d
			defined as `d = {
				'a': {
					'b': {
						'c': "object1",
						'f': "object2"
					},
					'e': "object3"
				},
				'd': {
					'g': "object4"
				}
			}` this function will return object1
		"""
		if len(path) == 0:
			return None
		if len(path) == 1:
			return dictionary[path[0]]
		else:
			# a KeyError exception will be raised if someone forgetts to provide an
			#argument to an option here. maybe sanitize input somehow?
			return self.walkDictPath(dictionary[path[0]], path[1:])

	def getCommand(self, commandList):
		"""Gets the selected command from the menu dictionary

		This uses the walkDictPath method to retrieve the selected rpc
		endpoint based on the list of values in commandList.

		Args:
			commandList (list): List of menu names to traverse

		Returns:
			Command: Instantiated command class, which can be called to
				execute the rpc endpoint
		"""
		# print "Walking path:"
		# print commandList
		# print "Walking tree:"
		# print self.menuDict
		command = self.walkDictPath(self.menuDict, commandList)
		if not command:
			raise NonExistantCommand
		return command

class ParseInput(object):
	def __init__(self, inputList):
		self.remainingArgs = inputList
		self.options = {}
		self.command = []
		self.commandArgs = {}
		self.parseInput()

	def parseInput(self):
		self.parseOptions()
		self.parseCommand()
		self.parseCommandArgs()

	def parseOptions(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.options[keyword] = value
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommand(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] != '-':
			self.command.append(self.remainingArgs[index])
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommandArgs(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				try:
					value = self.remainingArgs[index + 1]
				except IndexError:
					# There is no next error. Complain and quit
					sys.exit("Expected value in for argument, but got none.")
				index += 1
			self.commandArgs[keyword] = value
			index += 1

	def prepareAuthDict(self, config):
		tmpDict = {}
		# If the admin token was provided, add that to the auth dict and then
		# return since we don't need anything else.
		if "admin-token" in self.options:
			tmpDict["admin-token"] = self.options.pop("admin-token")
			self.commandArgs['auth'] = tmpDict
			return True
		# Add the username to the auth Dict
		if not config.username:
			print "No username was provided."
			return False
		tmpDict["username"] = config.username
		# Add the organization to the auth Dict
		if not config.organization:
			print "No organization was provided."
			return False
		tmpDict["organization"] = config.organization
		# If a password is provided, we want to use that instead of the token
		if config.password:
			tmpDict["password"] = config.password
		elif config.token_auth_enabled and config.token:
			tmpDict["token"] = config.token
		else:
			# Both values failed
			print "Neither password nor token were provided."
			return False
		self.commandArgs['auth'] = tmpDict
		return True

def printOutput(output):
	if output.value != 0:
		sys.stderr.write("An error was encountered:\n")
		sys.stderr.write("\n".join(output.message)+"\n")
	if output.tableHeaders:
		# Its a dictionary list, make a table and print it
		outputTable = PrettyTable(output.tableHeaders)
		outputTable.padding_width = 1
		for i in output.content:
			outputTable.add_row(i.values())
		print outputTable
	else:
		# It's just a list of strings, print each one
		# TODO: Maybe I just shouldn't support this...
		for i in output.content:
			print i

# if __name__ == "__main__":
# 	"""
# 	Usage:
# 	cssef-cli [OPTIONS] [COMMAND] [ARGUMENTS]
# 	"""
# 	# Parse the command line arguments
# 	cliInput = ParseInput()
# 	config = buildConfiguration(cliInput)
# 	# Establish rabbitmq connection
# 	config.establishApiConnection()
# 	# Load the available endpoints
# 	commandMenu = Menu(config)
# 	commandMenu.load()
# 	# Cache the endpoints if necessary
# 	if config.endpoint_cache_enabled:
# 		commandMenu.cacheEndpoints()
# 	# Attempt to renew the auth token permitted
# 	if config.token_auth_enabled and config.token_renewal_enabled and not config.admin_token:
# 		processTokenRenewal(config)
# 	else:
# 		print "[LOGGING] Skipping auth token renewal."

# 	# Get the command, instantiate it, then call it
# 	# This is super temporary - I just want to get all of the server side stuff fixed first
# 	try:
# 		command = commandMenu.getCommand(cliInput.command)
# 		output = command.execute(**cliInput.commandArgs)
# 	except NonExistantCommand as e:
# 		output = CommandOutput(**e.asReturnDict())
# 	# Now display the output
# 	output.display()
# 	output.exitWithValue()

if __name__ == "__main__":
	# # Ensure user data directory exists
	# if not os.path.exists(self.userDataDir):
	# 	os.makedirs(self.userDataDir)

	# Set up and configure the client
	userInput = ParseInput(sys.argv[1:])
	client = cssefclient.CssefClient()
	client.config.loadConfigFile('/etc/cssef/cssef.yml')
	client.config.loadConfigFile('~/.cssef/cssef.yml')
	client.config.loadConfigDict(userInput.options)

	# Make connection to server, load endpoints, authenticate
	client.connect()
	client.loadEndpoints()
	client.loadToken()

	# Call command and handle return
	commandMenu = Menu(client.config, client.endpoints)
	commandMenu.construct()

	command = commandMenu.getCommand(userInput.command)
	output = client.callEndpoint(command, userInput.commandArgs)
	printOutput(output)
	sys.exit(output.value)