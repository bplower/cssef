#!/usr/bin/python
import os
import sys
from getpass import getpass
import cssefclient
from prettytable import PrettyTable
from cssefclient.utils import RPCEndpoint
from cssefclient.tasks import AvailableEndpoints
from cssefclient.tasks import Login
from cssefclient.tasks import Logout
from cssefclient.errors import NonExistantCommand

class Menu(object):
	def __init__(self, config, endpoints):
		self.config = config
		self.availableEndpoints = endpoints
		self.menuDict = {}

	def construct(self):
		# Build dynamic rpc endpoints
		for moduleDict in self.availableEndpoints:
			self.menuDict[moduleDict['menuName']] = {}
			for endpointDict in moduleDict['endpoints']:
				self.menuDict[moduleDict['menuName']] = self.buildMenuBranch(
					self.menuDict[moduleDict['menuName']],	# This is the current menu
					endpointDict['menu'],					# This is the menu heiarchy
					endpointDict)							# This is the content for the end of the menu

		# Build local endpoints
		self.menuDict['login'] = Login(self.config)
		self.menuDict['logout'] = Logout(self.config)

	def buildMenuBranch(self, currentMenu, menuList, endpointContent):
		if len(menuList) == 1:
			# This means endpointContent is a dictionary that defines a rpc
			# endpoint. We now instantiate the endpoint from that dictionary
			currentMenu[menuList[0]] = RPCEndpoint.fromDict(
				self.config,
				endpointContent)
			return currentMenu
		else:
			try:
				currentMenu[menuList[0]] = self.buildMenuBranch(
					currentMenu[menuList[0]],
					menuList[1:],
					endpointContent)
			except KeyError:
				currentMenu[menuList[0]] = {}
				currentMenu[menuList[0]] = self.buildMenuBranch(
					currentMenu[menuList[0]],
					menuList[1:],
					endpointContent)
			return currentMenu

	def walkDictPath(self, dictionary, path):
		"""This will walk down the path l through dictionary d
		Example:
			Given list l defined as `l = ['a', 'b', 'c']` and dictionary d
			defined as `d = {
				'a': {
					'b': {
						'c': "object1",
						'f': "object2"
					},
					'e': "object3"
				},
				'd': {
					'g': "object4"
				}
			}` this function will return object1
		"""
		if len(path) == 0:
			return None
		if len(path) == 1:
			return dictionary[path[0]]
		else:
			# a KeyError exception will be raised if someone forgetts to provide an
			#argument to an option here. maybe sanitize input somehow?
			return self.walkDictPath(dictionary[path[0]], path[1:])

	def getCommand(self, commandList):
		"""Gets the selected command from the menu dictionary

		This uses the walkDictPath method to retrieve the selected rpc
		endpoint based on the list of values in commandList.

		Args:
			commandList (list): List of menu names to traverse

		Returns:
			Command: Instantiated command class, which can be called to
				execute the rpc endpoint
		"""
		# print "Walking path:"
		# print commandList
		# print "Walking tree:"
		# print self.menuDict
		command = self.walkDictPath(self.menuDict, commandList)
		if not command:
			raise NonExistantCommand
		return command

class ParseInput(object):
	def __init__(self, inputList):
		self.remainingArgs = inputList
		self.options = {}
		self.command = []
		self.commandArgs = {}
		self.parseInput()

	def parseInput(self):
		self.parseOptions()
		self.parseCommand()
		self.parseCommandArgs()

	def parseOptions(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0]
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument
				value = self.remainingArgs[index + 1]
				index += 1
			self.options[keyword] = value
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommand(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] != '-':
			self.command.append(self.remainingArgs[index])
			index += 1
		self.remainingArgs = self.remainingArgs[index:]

	def parseCommandArgs(self):
		index = 0
		while index < len(self.remainingArgs) and self.remainingArgs[index][0] == '-':
			argument = self.remainingArgs[index]
			argument = argument.strip('-')
			if len(argument.split("=")) > 1:
				# The value is in the same argument
				keyword = argument.split('=')[0].replace('-', '_')
				value = argument.split('=')[1]
			else:
				# The value is in the next argument
				keyword = argument.replace('-', '_')
				try:
					value = self.remainingArgs[index + 1]
				except IndexError:
					# There is no next error. Complain and quit
					sys.exit("Expected value in for argument, but got none.")
				index += 1
			self.commandArgs[keyword] = value
			index += 1

class AuthDict(object):
	def __init__(self, config, parsed_input):
		pass

def buildAuthDict(parsed_input, config):
	tmpDict = {}
	# If the admin token was provided, add that to the auth dict and then
	# return since we don't need anything else.
	#if "admin-token" in parsed_input.options:
	if config.admin_token:
		#tmpDict["admin-token"] = parsed_input.options.pop("admin-token")
		tmpDict["admin-token"] = config.admin_token
		return tmpDict
	# Add the username to the auth Dict
	if not config.username:
		print "No username was provided."
		return None
	tmpDict["username"] = config.username
	# Add the organization to the auth Dict
	if not config.organization:
		print "No organization was provided."
		return None
	tmpDict["organization"] = config.organization
	# If a password is provided, we want to use that instead of the token
	if config.password:
		tmpDict["password"] = config.password
	elif config.token_auth_enabled and config.token:
		tmpDict["token"] = config.token
	else:
		# If it's okay, prompt the user for a password
		if config.prompt_password:
			tmpDict["password"] = getpass()
		else:
			# Both values failed
			print "Neither password nor token were provided."
			return None
	return tmpDict


def printOutput(output):
	if not output:
		sys.stderr.write("Return values was not in correct output format.")
		sys.exit()
	if output.value != 0:
		sys.stderr.write("An error was encountered:\n")
		sys.stderr.write("\n".join(output.message)+"\n")
	if output.tableHeaders:
		# Its a dictionary list, make a table and print it
		outputTable = PrettyTable(output.tableHeaders)
		outputTable.padding_width = 1
		for i in output.content:
			outputTable.add_row(i.values())
		print outputTable
	else:
		# It's just a list of strings, print each one
		# TODO: Maybe I just shouldn't support this...
		for i in output.content:
			print i

if __name__ == "__main__":
	# # Ensure user data directory exists
	# if not os.path.exists(self.userDataDir):
	# 	os.makedirs(self.userDataDir)

	# Set up and configure the client
	userInput = ParseInput(sys.argv[1:])
	client = cssefclient.CssefClient()
	client.config.loadConfigFile(client.config.globalConfigPath)
	client.config.loadConfigFile(client.config.configPath)
	client.config.loadConfigDict(userInput.options)

	# Prepare the auth dictionary
	auth_dict = buildAuthDict(userInput, client.config)
	if not auth_dict:
		sys.exit()
	userInput.commandArgs['auth'] = auth_dict

	# Make connection to server, load endpoints, authenticate
	client.connect()
	client.loadEndpoints()
	client.loadToken(auth = userInput.commandArgs['auth'])

	# Call command and handle return
	commandMenu = Menu(client.config, client.endpoints)
	commandMenu.construct()

	command = commandMenu.getCommand(userInput.command)
	output = client.callEndpoint(command, userInput.commandArgs)
	printOutput(output)
	sys.exit(output.value)